\chapter{Implementation} \label{ch:implementation}

\section{User Interface}
\begin{figure}
	\centering
	\includegraphics[width=0.5\linewidth]{screenshot_popup.png}
	\caption{Popup window of CookieAudit}
	\label{fig:screenshot-popup}
\end{figure}
The primary way for users to interact with a browser extension is through its popup.
It can be opened by clicking the extension's action icon in the browser toolbar.
Popups are programmed using the same web technologies as websites: HTML, CSS, and JavaScript.
In CookieAudit, users can initiate a website scan, stop it, or download a report summarizing the scan results via the popup.
Additionally, CookieAudit displays real-time information about the scan's progress.
For developing the popup's user interface, we chose to use the React JavaScript library.
React offers a declarative programming model that keeps the displayed data synchronized with the underlying data storage.

\section{Cookie Notice Selection}
CookieAudit is designed to automatically analyze and interact with arbitrary cookie notices. 
The initial identification of which HTML element represents the cookie notice could be done either automatically or manually by the user.
Any approach of automatic notice selection, e.g., based on heuristics or NLP models, will be error-prone.
On the other hand, a manual selection could provide accuracy with minimal user effort.
Next, we will give an overview of both approaches and their limitations.

\subsection{Automatic Selection}
Any approach to automated notice selection will always be limited in its accuracy.
For example, Bouhoula et al.~\cite{bouhoula2023automated} achieve a precision of 100\% and a recall of 86.9\%, even though the authors improve in both metrics by building upon the approaches for automatic selection of previous studies.
Those issues fundamentally stem from the many ways of implementing cookie notices in HTML and JavaScript.
Nevertheless, we will present some of those heuristics.

\subsubsection{Crowdsourced Selectors}
HTML elements can be identified with \emph{selectors}. 
Crowdsourced efforts, such as EasyList Cookie, maintain lists of cookie notice selectors.
Automated crawlers by Kampanos et al.~\cite{kampanos2021accept} and Bouhoula et al.~\cite{bouhoula2023automated} have used EasyList to find potential cookie notices on websites.

\subsubsection{Stack Level}
The \emph{z-index} is a CSS property of HTML elements that makes elements with a high index appear above elements with a low index. 
Because a user should quickly see a cookie notice, websites can use a high \emph{z-index} on the notice to let it cover the rest of the website. 
This qualifier has been used by Khandelwal et al.~\cite{khandelwal2023automated} and Bouhoula et al.~\cite{bouhoula2023automated}.

\subsection{User-Aided Selection} \label{subsec:user-aided-selection}
CookieAudit is intended for semi-automated website analysis.
We can therefore rely on user help by using a cookie notice picker tool.
To specify the element containing a notice, users only needs to hover the mouse over it and then confirm the selection. 
An example can be seen in \cref{fig:screenshot-selection}.

\begin{figure}
	\centering
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{media/screenshot_unselected.png}
	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{media/screenshot_selected.png}      
	\end{minipage}
	\caption{Manual notice selection.}
	\label{fig:screenshot-selection}
\end{figure}

The picker is implemented as a \emph{content script}. 
As explained in \cref{subsec:content-scripts}, content scripts are JavaScript programs that can interact with the web page.

The activated picker tool listens for cursor movement by the user. 
On movement, it reads the coordinates of the cursor and determines the HTML element at that position.
The picker changes the styling of the determined element to provide visual feedback.
CookieAudit needs users to select the element corresponding to the complete cookie notice. 
Occasionally, the desired element is only a container whose area is filled out by the children (see \cref{fig:notice-fillout}).
In this case, every click inside the notice will select a child element rather than the entire notice container. 
Therefore, users won't be able to select the whole notice by simply hovering the cursor.
As a solution, we implement a context menu that appears after the user has clicked on an element.
With the menu, the user can traverse up the DOM tree to the element containing the whole cookie notice.
In the end, the selection can be confirmed via the context menu.


\begin{figure}
	\centering
	\begin{minipage}{0.48\textwidth}
		\centering
		\begin{tikzpicture}[]
			% Outer box
			\draw [thick] (0,0) rectangle (4,-3);
			
			% Child boxes
			\draw [fill=green!10] (0,0) rectangle (4,-0.7) node[midway, text=green!50!black] {Child 1};
			\draw [fill=orange!10] (0,-0.7) rectangle (4,-2.3) node[midway, text=orange] {Child 2};
			\draw [fill=purple!10] (0,-2.3) rectangle (4,-3) node[midway, text=purple] {Child 3};
		\end{tikzpicture}
	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\begin{tikzpicture}[]
			% Outer box
			\draw [thick] (0,0) rectangle (4,-3);
			
			% Child boxes
			\draw [fill=green!10] (0.2,-0.2) rectangle (3.8,-0.8) node[midway, text=green!50!black] {Child 1};
			\draw [fill=orange!10] (0.2,-0.8) rectangle (3.8,-2) node[midway, text=orange] {Child 2};
			\draw [fill=purple!10] (0.2,-2) rectangle (3.8,-2.6) node[midway, text=purple] {Child 3};
		\end{tikzpicture}     
	\end{minipage}
	\caption{Any location in the left notice will map to one of the children. Only the white area in the right notice will be mapped to the whole notice.}
	\label{fig:notice-fillout}
\end{figure}

The complexity of both HTML and JavaScript results in many possible ways of implementing cookie notices.
Because of those implementation details, we encountered several edge cases during the manual testing of CookieAudit.
Next, we will present our solutions.

\subsubsection{Inline Frame}
An inline frame allows developers to embed another HTML context by linking to a URL~\cite{iframeMdn}.
Some websites implement cookie notices with an \texttt{iframe} that refers to a Consent Management Platform.
To enable users to select the cookie notice, we inject the \emph{picker tool} content script not only into the original web page, but also into all \texttt{iframe} elements.

\subsubsection{Shadow DOM}
A shadow DOM separates elements inside of it from the influence of the main document's JavaScript and CSS~\cite{shadowDomMdn}.
Some developers use this feature to integrate cookie notices into their web page.
This encapsulation prevents our picker content script from directly accessing the cookie notice elements. 
To address this, we implement a solution during user notice selection.
As described before, we continuously query for the element that is located at the user's cursor coordinates.
When a user hovers over an element within a shadow DOM, this query will return the root of the shadow DOM (\emph{shadow root}). 
We then check if the element is indeed a shadow root by reading the \texttt{shadowRoot} property of the HTML element.
If so, we explicitly enter the shadow DOM context and query for the element at the user's cursor coordinates once again. 

\subsubsection{Dialog Element}
The \texttt{dialog} element is an HTML element that can be used to build dialog boxes such as cookie notices.
When opened, it displays above all elements of the website and will cover elements with arbitrary \texttt{z-index} values. 
Multiple \texttt{dialog} elements are stacked based on their opening order, with the most recent dialog displayed on top.
If used to display a cookie notice, a dialog element would also hide our picker tool context menu.
Therefore, we have implemented the menu with a \texttt{dialog} element.
By opening our dialog after the cookie notice renders, we ensure that the menu will be visible and accessible to CookieAudit users.

\section{Cookie Notice Analysis}
For the analysis of a selected cookie notice, we rely on the extraction and classification functionality developed by Bouhoula et al.~\cite{bouhoula2023automated}.
We use their NLP models to detect declared cookie purposes in the cookie notice text and to classify interactive elements of the notice for later interaction.
In case of a detected \emph{Settings} button, we additionally analyze the corresponding settings.

\subsection{Extraction} \label{subsec:extraction}
To extract the cookie notice text, we iterate through all visible elements inside the notice and concatenate their text content.
For nested elements, which are common in HTML's tree-like structure, we recursively repeat this process.

To enable automated interaction with cookie notices, CookieAudit needs to identify all clickable elements.
We will use the criteria proposed by Bouhoula et al.~\cite{bouhoula2023automated}.
First, we will consider only elements of type \texttt{div}, \texttt{span}, \texttt{a}, \texttt{button} or \texttt{input} that fulfill one of the following criteria: 
has the accessibility (ARIA) role \texttt{button}, 
has the attribute \texttt{onclick} or
has a non-negative \texttt{tabindex}.
Furthermore, we consider elements that, when hovered over, change the mouse to a pointer.
The last criterion was added based on manual testing, as it captured some interactive elements missed by the other rules in rare cases.

\subsection{Classification}
According to the GDPR, users need to be able to form informed and explicit consent.
Therefore, a cookie notice needs to (i) declare the purposes of its data collection and processing and (ii) provide interactive elements for the user to express his explicit consent (\emph{Accept} button) or rejection (\emph{Reject} button).
Bouhoula et al.~\cite{bouhoula2023automated} trained the two BERT models~\cite{devlin2018bert}, the \emph{purpose detection} model and the \emph{interactive elements} model, for both classification problems.
Next, we will explain how we integrate and use the models.

\subsubsection{Purpose Detection Model}

The purpose detection model classifies sentences into either Purposes for Analytics/Advertising (profiling, advertising, custom content, analytics, and social media features) or Other Purposes (essential functionalities, offering service, and website/UX enhancement).
Because the models only work on English input, CookieAudit first translates (if necessary) the cookie notice text using a public translation API.
The translated text is then classified with the browser library Transformer.js~\cite{huggingface2023transformers} which makes it possible to efficiently\footnote{
We have found the average time of a sentence classification to be 209ms. 
To determine this, we benchmarked the classification of 1187 sentences using the purpose detection model in a Chrome extension using Transformers.js.
The sentences are from a dataset by Santos et al.~\cite{santos2021cookie} and were also used to train the purpose detection model.
The benchmark was done on a MacBook Pro with an Intel i5 7267U 3.10GHz CPU and 16 GB memory while no other user space programs were running.
} run BERT models on the client.

\subsubsection{Interactive Elements Model}
CookieAudit has to understand the functionality of the interactive cookie notice elements to be able to automatically interact with them.
The interactive elements model by Bouhoula et al. classifies the texts of buttons as either accept, reject, close, save, settings and other.
Because it is also a BERT model we can run it, after a translation of the texts, equivalently to the purpose detection model.

\subsection{Exploration}
Cookie notices can offer additional settings.
The settings may contain additional text with a declaration of the cookie purpose, or interactive elements, e.g, to reject specific cookie categories or even all non-necessary cookies.
If a \emph{Settings} button is available in a cookie notice, clicking it may change the content of the current notice to display the settings, open a new settings notice or open a separate web page with the settings.
Because of the mentioned text contents and interactive elements, CookieAudit needs to analyze the settings.

Similar to the approach implemented by Bouhoula et al.~\cite{bouhoula2023automated}, CookieAudit clicks on all interactive elements that were classified as \emph{Settings}.
If no interactive elements were classified as \emph{Settings}, CookieAudit alternatively uses three \emph{Other} elements. 
In particular, the \emph{Other} elements are sorted by their y-coordinates, such that elements that are located on the bottom of the cookie notice are used.
This simple heuristic is based on the observation that the \emph{Settings} button is often located at the bottom.
After the \emph{Settings} have been opened and identified, CookieAudit will again proceed as for the original cookie notice, retrieving and analyzing the text and interactive elements.
CookieAudit adds the elements of type \emph{Reject}, \emph{Close} and \emph{Save Settings} to the \texttt{ieToInteract} array as a sequence of selectors: first the \emph{Settings} element selector, then the second layer element selector. 

Based on the work by Bouhoula et al.~\cite{bouhoula2023automated}, we implemented the detection and handling of the following three scenarios:

\subsubsection{New Cookie Notice}
The cookie notice settings can be displayed inside a new notice that appears, e.g., above the original cookie notice. 
CookieAudit detects this situation if one of the following criteria holds:

\begin{itemize} 
    \item a query for the cookie notice with the selector returns \texttt{null},
    \item the cookie notice is not visible anymore (e.g., if the notice has or inherits an \texttt{opacity} of 0, has or inherits the CSS \texttt{visibility} of hidden or collapse, or has an area of 1 pixel or less),
    \item the notice still exists and is visible, but \emph{neither} its text content nor the dimensions (height and width) have changed after the interactive element click, or
    \item the cookie notice is covered by another element. CookieAudit runs \texttt{elementFromPoint()} at the coordinates of the cookie notice center. If the returned element is not the notice or contained in the notice, we consider the notice covered.
\end{itemize}

To identify the settings element and start the analysis, CookieAudit activates the \emph{Cookie Notice Picker} (as described in \cref{subsec:user-aided-selection}) and lets the user manually select the settings notice.

\subsubsection{New Web Page}
CookieAudit stores the URL of the web page before the interactive element click and compares it to the URL of the web page after the click.
If it has changed, CookieAudit classifies the outcome as a new notice on a separate web page.
In this case, CookieAudit starts the cookie notice picker. 
The picker can be used to select both settings that are part of the normal flow of the web page, or displayed as a hovering dialog.
After the user selection and subsequent settings analysis, CookieAudit returns to the URL where the scan was started.

\subsubsection{Same Cookie Notice}
If neither the criteria of a \emph{New Cookie Notice} nor \emph{New Web Page} apply, CookieAudit assumes the settings to be now contained in the original cookie notice.
This effectively means that the original cookie notice is still visible, the contents, or dimensions have changed and the URL of the web page is still the same.
CookieAudit directly starts the settings notice analysis without any user interaction.

\section{Dark Pattern Detection}
\section{Managing Page Loads and Changes}
\section{Report Creation}